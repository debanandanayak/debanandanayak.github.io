[{"id":54132,"question":"<p dir=\"ltr\"><span>Consider the following code snippet:</span><br><span>for i = 1 to n:</span><br><span>&nbsp; &nbsp;for j = 1 to n:</span><br><span>&nbsp; &nbsp; &nbsp; &nbsp;print(i, j)</span></p><p dir=\"ltr\"><span>What is the time complexity of this code snippet?&nbsp;</span><br><span>&nbsp;</span></p>","answers":[{"id":219444,"answer":"<p dir=\"ltr\"><span>O(n</span><sup><span>2)</span></sup></p>","correct":true},{"id":219445,"answer":"<p dir=\"ltr\"><span>O(n)</span></p>","correct":false},{"id":219446,"answer":"<p dir=\"ltr\"><span>O(n</span><sup><span>3</span></sup><span>)</span></p><p dir=\"ltr\"><br></p>","correct":false},{"id":219447,"answer":"<p dir=\"ltr\"><span>O(1)</span></p>","correct":false}],"explanation":"<p dir=\"ltr\"><span>The code snippet contains two nested loops, each iterating from 1 to n. As a result, the total number of iterations is n * n = n^2.</span></p>"},{"id":54130,"question":"<p dir=\"ltr\"><span>Which asymptotic notation is used to represent the average-case time complexity of an algorithm?</span></p>","answers":[{"id":219436,"answer":"<p dir=\"ltr\"><span>Big-O Notation ( O- Notation ) </span></p>","correct":false},{"id":219437,"answer":"<p dir=\"ltr\"><span>Theta Notation ( Θ-notation )</span></p>","correct":true},{"id":219438,"answer":"<p dir=\"ltr\"><span>Omega Notation (Ω-notation)</span></p>","correct":false},{"id":219439,"answer":"<p dir=\"ltr\"><span>None of the above</span></p>","correct":false}],"explanation":"<p dir=\"ltr\"><span>The correct answer is B)Theta Notation ( Θ-notation ). </span></p><p dir=\"ltr\"><span>Explanation: The average-case time complexity of an algorithm is denoted using the Theta notation (Θ). It represents the tight bound on the growth rate of the algorithm in the average case, providing a range within which the algorithm's performance falls as the input size increases.</span><br><span>&nbsp;</span></p>"},{"id":54128,"question":"\n<p>Consider the recurrence relation T(n) = 2T(n/2) + n/log n. What is the time complexity of the algorithm based on this recurrence relation?</p>\n","answers":[{"id":219428,"answer":"\n<p>Θ(n) &nbsp;</p>\n","correct":false},{"id":219429,"answer":"\n<p>Θ(n log n)</p>\n","correct":false},{"id":219430,"answer":"\n<p>Θ(n<sup>2</sup>) &nbsp;</p>\n","correct":false},{"id":219431,"answer":"\n<p>Θ(n log<sup>2</sup> n) &nbsp;</p>\n","correct":true}],"explanation":"\n<p>The correct answer is D) Θ(n log^2 n).</p>\n\n<p>Explanation: The recurrence relation T(n) = 2T(n/2) + n/log n belongs to the Master Theorem's Case 2. Here, a = 2, b = 2, and f(n) = n/log n. In this case, f(n) = Θ(n/log n) and log_b(a) = 1. Since f(n) is larger than n^(log_b(a)), the time complexity is Θ(n log^2 n).<br>&nbsp;</p>\n"},{"id":54127,"question":"\n<p>What is the time complexity of an algorithm that runs in Θ(n^2) and requires 3n^2 + 5n + 7 operations?</p>\n","answers":[{"id":219424,"answer":"\n<p>Θ(n) &nbsp;</p>\n","correct":false},{"id":219425,"answer":"\n<p>Θ(n<sup>2</sup>) &nbsp;</p>\n","correct":true},{"id":219426,"answer":"\n<p>Θ(n<sup>3</sup>)</p>\n","correct":false},{"id":219427,"answer":"\n<p>Θ(1) &nbsp;</p>\n","correct":false}],"explanation":"\n<p>The correct answer is B) Θ(n^2).</p>\n\n<p>Explanation: The given algorithm's time complexity is Θ(n^2), which means it takes approximately n^2 operations. The specific coefficient values (3, 5, 7) do not change the order of growth in Big Theta notation.<br>&nbsp;</p>\n"},{"id":45940,"question":"\n<p>Consider a list of recursive algorithms and a list of recurrence relations as shown below. Map the given recurrence relations that corresponds to exactly one algorithm and is used to derive the time complexity of the algorithm.</p>\n<figure class=\"table\"><table><thead><tr><th>&nbsp;</th><th><strong>Recursive Algorithm &nbsp; &nbsp;&nbsp;</strong></th><th>&nbsp;</th><th><strong>Recurrence Relation</strong></th><th>&nbsp;</th></tr></thead><tbody><tr><td>P.</td><td>Binary search</td><td>I.</td><td>T(n) = T(n-k) + T(k) + cn</td><td>&nbsp;</td></tr><tr><td>Q.</td><td>Merge sort</td><td>II.</td><td>T(n) = 2T(n-1) + 1</td><td>&nbsp;</td></tr><tr><td>R.</td><td>Quick sort</td><td>III.</td><td>T(n) = 2T(n/2) + cn</td><td>&nbsp;</td></tr><tr><td>S.</td><td>Tower of Hanoi</td><td>IV.</td><td>T(n) = T(n/2) + 1</td><td>&nbsp;</td></tr></tbody></table></figure>\n<p>[GATE 2004]</p>\n","answers":[{"id":187154,"answer":"\n<p>P-II, Q-III, R-IV, S-I</p>\n","correct":false},{"id":187155,"answer":"\n<p>&nbsp;P-IV, Q-III, R-I, S-II</p>\n","correct":true},{"id":187156,"answer":"\n<p>P-III, Q-II, R-IV, S-I</p>\n","correct":false},{"id":187157,"answer":"\n<p>P-IV, Q-II, R-I, S-III</p>\n","correct":false}],"explanation":"\n<p>Merge Sort: &nbsp; &nbsp;T(n) = 2T(n/2) + Θ(n). It falls in case 2 as c is 1 and Log<sub>b</sub>a] is also 1&nbsp;and&nbsp; the solution is Θ(n Logn) <i>//time complexity can be evaluated using Master Method</i></p>\n\n<p>Binary Search: T(n) = T(n/2) + Θ(1). It also falls in case 2 as c is 0 and Log<sub>b</sub>a is also 0&nbsp;and&nbsp;the solution is Θ(Logn) <i>//time complexity can be evaluated using Master Method</i></p>\n\n<p>Quick Sort: Time taken by QuickSort in general can be written as&nbsp; T(n) = T(k) + T(n-k-1) + <img class=\"image_resized\" style=\"width:auto;\" src=\"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-a372b7ef1ffaec3b4ad80e0141550990_l3.svg\" alt=\"\\theta\">(n)</p>\n\n<p>Tower of Hanoi : T(n) = 2T(n-1) + 1</p>\n\n<p>Hence, option B is correct&nbsp;</p>\n"},{"id":35058,"question":"<p dir=\"ltr\"><span>Which of the following recurrence relations do not represent the worst case of Quick Sort?</span></p>","answers":[{"id":145924,"answer":"<p dir=\"ltr\"><span>T(n) = T(n/2) + O(n)</span><br><span>&nbsp;</span></p>","correct":false},{"id":145925,"answer":"<p dir=\"ltr\"><span>T(n) = T(n-1) + T(0) + O(n)</span></p>","correct":true},{"id":145926,"answer":"<p dir=\"ltr\"><span>T(n) = 2T(n/2) + O(n)</span></p>","correct":false},{"id":145927,"answer":"<p dir=\"ltr\"><span>T(n) = 4T(n/2) + O(1)</span></p>","correct":true}],"explanation":"<p dir=\"ltr\"><span>Worst case scenario of Quick sort occurs if the array is already sorted (or reverse sorted). </span></p><p dir=\"ltr\"><span>In the worst case scenario, the partition divides the array into two subarrays where one subarray has n−1 elements and the other has 0 elements. </span></p><p dir=\"ltr\"><span>therefore the recurrence relation will be T(n) = T(n−1) + T(0) + O(n)</span></p><p dir=\"ltr\"><b><strong>B is the correct option. </strong></b></p>"},{"id":20816,"question":"<p dir=\"ltr\"><span>Consider the following two recurrence relations T(n) and S(m):</span></p><figure class=\"image\"><img src=\"https://media.geeksforgeeks.org/wp-content/uploads/20250103120201478301/sudo-gate-q6-2.webp\" alt=\"sudo-gate-q6-2\" width=\"800\" height=\"230\" srcset=\"https://media.geeksforgeeks.org/wp-content/uploads/20250103120201478301/sudo-gate-q6-2.webp 800w,https://media.geeksforgeeks.org/wp-content/uploads/20250103120201478301/sudo-gate-q6-2-100.webp 100w,https://media.geeksforgeeks.org/wp-content/uploads/20250103120201478301/sudo-gate-q6-2-200.webp 200w,https://media.geeksforgeeks.org/wp-content/uploads/20250103120201478301/sudo-gate-q6-2-300.webp 300w,https://media.geeksforgeeks.org/wp-content/uploads/20250103120201478301/sudo-gate-q6-2-660.webp 660w,https://media.geeksforgeeks.org/wp-content/uploads/20250103120201478301/sudo-gate-q6-2-768.webp 768w\"><figcaption> </figcaption></figure><figure class=\"image\"><img src=\"https://media.geeksforgeeks.org/wp-content/uploads/20250103120258832412/sudogate-q6-1.webp\" alt=\"sudogate-q6-1\" width=\"800\" height=\"230\" srcset=\"https://media.geeksforgeeks.org/wp-content/uploads/20250103120258832412/sudogate-q6-1.webp 800w,https://media.geeksforgeeks.org/wp-content/uploads/20250103120258832412/sudogate-q6-1-100.webp 100w,https://media.geeksforgeeks.org/wp-content/uploads/20250103120258832412/sudogate-q6-1-200.webp 200w,https://media.geeksforgeeks.org/wp-content/uploads/20250103120258832412/sudogate-q6-1-300.webp 300w,https://media.geeksforgeeks.org/wp-content/uploads/20250103120258832412/sudogate-q6-1-660.webp 660w,https://media.geeksforgeeks.org/wp-content/uploads/20250103120258832412/sudogate-q6-1-768.webp 768w\"><figcaption> </figcaption></figure><p dir=\"ltr\"><span>What will be complexity of above relations?</span></p>","answers":[{"id":88841,"answer":"<p dir=\"ltr\"><span>O(log</span><sub><span>2</span></sub><span>n) and O(log</span><sub><span>2</span></sub><span>m) respectively</span></p>","correct":false},{"id":88842,"answer":"<p dir=\"ltr\"><span>O(n) and O(log</span><sub><span>2</span></sub><span>m) respectively</span></p>","correct":false},{"id":88843,"answer":"<p dir=\"ltr\"><span>O(log</span><sub><span>2</span></sub><span>n) and O(m) respectively</span></p>","correct":true},{"id":88844,"answer":"<p dir=\"ltr\"><span>O(n) and O(m) respectively</span></p>","correct":false}],"explanation":"<p dir=\"ltr\"><span>For recurrence relation T(n): </span></p><pre><span>T(n) = T(n / 2) + C</span><br><span>= T(n / 4) + C + C</span><br><span>= T(n / 8) + 3*C</span><br><span>.</span><br><span>.</span><br><span>. </span><br><span>N will be divided until it becomes 1. So,</span><br><br><span>= T(n / 2</span><sup><span>k</span></sup><span>) + (k-1) * C</span><br><span>That means, n / 2</span><sup><span>k</span></sup><span> = 1 </span><br><span>= k = log</span><sub><span>2</span></sub><span>n </span><br><br><span>T(n) = 1 + (log</span><sub><span>2</span></sub><span>n - 1) * C</span><br><span>T(n) = O(log</span><sub><span>2</span></sub><span>n) </span></pre><p dir=\"ltr\"><span>  And, for recurrence relation S(m): </span></p><pre><span>S(m) = T(m / 2) + m </span><br><span>= T(m / 4) + m / 2 + m</span><br><span>= T(m / 8) + m / 4 + m / 2 + m</span><br><span>.</span><br><span>.</span><br><span>.</span><br><span>.</span><br><span>m will be divided until it becomes 1</span><br><span>S(m) = T( m / 2</span><sup><span>k</span></sup><span>) + m / 2</span><sup><span>k - 1</span></sup><span> + m / 2</span><sup><span>k - 2</span></sup><span> ... + 1</span><br><span>= 1 + m *[ (1 / 2)</span><sup><span>k - 1</span></sup><span> + (1 / 2)</span><sup><span>k - 2</span></sup><span> + (1 / 2)</span><sup><span>k - 3</span></sup><span> ... + 1]</span><br><span>= 1 + m * [ 1 + 1 / 2 + 1 / 4 + 1 / 8 + 1 / 16 ... + 1 / 2</span><sup><span>k - 1</span></sup><span> ]</span><br><span>= 1 + m * [ 1 * (1 - 1/2</span><sup><span>k - 1</span></sup><span>) / 1 - 1/2]</span><br><span>= 1 + m * [ 1 * (1 - 1/2</span><sup><span>log</span></sup><sub><span>2</span></sub><sup><span>m - 1</span></sup><span>) / 1 - 1/2]</span><br><span>= 1 + m * [ 2 * ( 1 - 2</span><sup><span>1 - log</span></sup><sub><span>2</span></sub><sup><span>m</span></sup><span>)]</span><br><span>= 1 + m * [ 2 * (m - 2) / m]</span><br><span>= O(m) </span></pre><p dir=\"ltr\"><span>  So, option (C) is correct.</span></p>"},{"id":74679,"question":"<p dir=\"ltr\"><span>Consider the following recurrence relation for an algorithm’s time complexity:</span></p><p dir=\"ltr\"><span>T(n)=3T(n/4)+O(n)</span></p><p dir=\"ltr\"><span>Using the </span><b><strong>Master Theorem</strong></b><span>, what is the time complexity of the algorithm?</span></p>","answers":[{"id":297839,"answer":"<p dir=\"ltr\"><span>O(n log n)</span></p>","correct":true},{"id":297840,"answer":"<p dir=\"ltr\"><span>O(n)</span></p>","correct":false},{"id":297841,"answer":"<p dir=\"ltr\"><span>O(n</span><sup><span>2</span></sup><span>)</span></p>","correct":false},{"id":297842,"answer":"<p dir=\"ltr\"><span>None of these</span></p>","correct":false}],"explanation":"<p dir=\"ltr\"><b><strong>Correct Answer:</strong></b><span> A)    O(n log n)</span></p>"},{"id":74635,"question":"<p dir=\"ltr\"><span>You are given a recursive function f(n) that divides n by 2 at each recursive call, and then performs a constant amount of work at each level. The recurrence relation for the time complexity is:</span></p><p dir=\"ltr\"><span>T(n)=T(n/2)+O(1)</span></p><p dir=\"ltr\"><span>What is the </span><b><strong>worst-case time complexity</strong></b><span> of this function using the Master Theorem?</span></p>","answers":[{"id":297663,"answer":"<p dir=\"ltr\"><span>O(log n)</span></p>","correct":true},{"id":297664,"answer":"<p dir=\"ltr\"><span>O(n)</span></p>","correct":false},{"id":297665,"answer":"<p dir=\"ltr\"><span>O(n log n)</span></p>","correct":false},{"id":297666,"answer":"<p dir=\"ltr\"><span>O(1)</span></p>","correct":false}],"explanation":"<p dir=\"ltr\"><b><strong>Correct Answer:</strong></b><span> A) O(log n)</span><br><b><strong>Explanation:</strong></b><br><span>The recurrence relation matches the form of the Master Theorem where a=1,b=2,d=0a = 1, b = 2, d = 0a=1,b=2,d=0. Since log⁡ba=log⁡21=0, and the function at each level does O(1) work, the time complexity is O(log⁡ n).</span></p>"},{"id":78758,"question":"<p dir=\"ltr\"><span>The time complexity of an algorithm is O(2^n). If the input size doubles, approximately how much does the running time increase?</span></p>","answers":[{"id":313628,"answer":"<p><span>2 </span></p>","correct":false},{"id":313629,"answer":"<p dir=\"ltr\"><span>n </span></p>","correct":false},{"id":313630,"answer":"<p dir=\"ltr\"><span>2</span><sup><span>n</span></sup></p>","correct":true},{"id":313631,"answer":"<p dir=\"ltr\"><span>n</span><sup><span>2</span></sup></p>","correct":false}],"explanation":"<p dir=\"ltr\"><span>If the time complexity of an algorithm is O(2^n), </span><br><span>On doubling the input size </span><br><span>time complexity becomes 2</span><sup><span>2n</span></sup><span> = 2</span><sup><span>n</span></sup><span> × 2</span><sup><span>n</span></sup><span> </span></p><p dir=\"ltr\"><span>on doubling the input the running time increases by 2</span><sup><span>n</span></sup><span> times. </span></p>"}]